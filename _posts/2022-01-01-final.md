---
title: 期末复习
author: hyc
date: 2022-01-01
category: Python
layout: post
---



[微机原理复习题目(带答案) - 道客巴巴 (doc88.com)](https://www.doc88.com/p-105556572442.html?r=1)

[微机原理试题及答案 (ruiwen.com)](https://www.ruiwen.com/shiti/1033338.html)

[微机原理试题集题库(带答案) - 豆丁网 (docin.com)](https://www.docin.com/p-2194915799.html)

[微机原理复习题目 (带答案） - 道客巴巴 (doc88.com)](https://www.doc88.com/p-0334731571579.html?s=rel&id=1)

[微机接口技术与应用_习题集(含答案) - 道客巴巴 (doc88.com)](https://www.doc88.com/p-9853549059494.html?r=1)



## 大纲

![image-20220105120132171](/assets/2022-01-01-final.assets/image-20220105120132171.png)



## 第一章：微处理器基础

- 数值信息的表示：浮点数转换，原码补码，常见字符的ASCII码，汉字编码的原理



| 字符 | ASCII码（American Standard Code for Information Interchange） |
| ---- | ------------------------------------------------------------ |
| '0'  | 48                                                           |
| 'A'  | 65                                                           |
| 'a'  | 97                                                           |



补码表示的16位带符号数字8088H除以8

1000 0000 1000 1000 原码 1111 1111 0111 1000   除以8 -111 1111 0111 1000/1000=-111 1111 0111 1= -1111 1110 1111=1000 1111 1110 1111 -> 1111 0000 0001 0001   这个情况比较特殊，刚好能整除，最后的结果相当于原数右移3位，最高位补符号位1

定点除法比较复杂，可以用不恢复余数法（也叫加减交替法；原码/补码除法）

[补码除法规则说明 - 百度文库 (baidu.com)](https://wenku.baidu.com/view/76c6ee0d25284b73f242336c1eb91a37f011320e.html)



同符号的数相减会有进位、不会有溢出？



![image-20220105120009230](/assets/2022-01-01-final.assets/image-20220105120009230.png)

## 第二章：微型计算机原理与体系结构

- 冯诺依曼组成原理，改进的哈佛结构，本质区别
- **8086的内核结构，寄存器基本作用，地址线条数，寻址**
- **80386的变化，结构特点，分段分页的作用，保护地址，GDTR，LDTR，地址计算**
- CISC和RISC的区别
- 存储字系统金字塔，是什么，为什么
- 流水线是什么，什么是超标量
- 寻址方式





## 第三章：总线与存储

- 总线的特性、分类、三态逻辑
- 异步通信的原理，双方握手
- 总线的性能指标
- **存储器的分类、存储器的层次**
- 静态和动态RAM的比较
- 大小端模式
- **存储器的地址计算**
- 存储器的容量扩展
- 存储器和CPU的连接，SRAM和DRAM的区别



[存储器习题解答 - 百度文库 (baidu.com)](https://wenku.baidu.com/view/34c425597275a417866fb84ae45c3b3566ecdd36.html)



- 数据总线(data bus) — 传输数据、状态信息(双向、三态)
- 地址总线(address bus) — 传输地址信息(单向、三态)
- 控制总线(control bus) — 传输控制信号(单向)



![image-20220105163709780](/assets/2022-01-01-final.assets/image-20220105163709780.png)



### 8086存储器分为偶体寄存器与奇体存储器

![image-20220105170825601](/assets/2022-01-01-final.assets/image-20220105170825601.png)

该存储器的存储容量为2^16*16bit；A16-19地址引脚是固定的，由高到低分别为1100，地址范围为C0000H到CFFFFH

右边那列由A0选通，存取的是偶数位地址；左边那列由~BHE选中高地址

1.8086cpu访问偶地址的字节单元时，cpu输出A0=0,选中偶体存储器，数据总线的低8位上传输，花费一个总线周期。

2.访问奇地址的字节单元时，输出A0=1, ~BHE低电平，选中奇体存储器，数据在数据总线的高8位上传输，花费一个总线周期。

3.访问偶地址开始的一个字单元时，此时输出A0=0, ~BHE=0，两个存储器同时被选中，数据线的低8位与高8位同时传输，因此，对所有位于偶地址的字单元，8086只需要一个总线周期。

4.访问奇地址开始的一个字单元时，第一个总线周期，cpu输出A0=1，~BHE=0,奇体存储器被选中，奇体存储器中低字节数据在数据总线的高8位上传输，第二个总线周期，cpu=A0, ~BHE=1，偶体存储器被选中，数据在数据总线的低8位上传输。



### Cache

- 直接映射
  主存地址格式：主存区号-区内块号-块内地址
  Cache地址格式：区内块号-块内地址
- 全相连映射
  主存：主存块号-块内地址
  Cache：Cache块号-块内地址
- n路（即每组包含n块）组相联映射
  主存：主存区号-区内块号-块内地址
  Cache：Cache组号-块号-块内地址



![image-20220105225454278](/assets/2022-01-01-final.assets/image-20220105225454278.png)

DRAM 行列复用，相当于有9\*2=18根地址线，所以最大容量为$2^{18}*8bit$=256KB



地址/数据总线复用的情况下，存储器地址线和CPU地址线引脚<u>需通过地址锁存器相连</u>



![image-20220106093445091](/assets/2022-01-01-final.assets/image-20220106093445091.png)

选C，为什么？



![image-20220106093505275](/assets/2022-01-01-final.assets/image-20220106093505275.png)

选A，内部中断优先级最高？



![image-20220106123229383](/assets/2022-01-01-final.assets/image-20220106123229383.png)

![image-20220106123243355](/assets/2022-01-01-final.assets/image-20220106123243355.png)

## 第四章：数据传输与输入输出接口

- 数据传输方式：查询，中断，DMA，三种方式的特点，区别
- 中断控制器芯片8259的基本特点，多片级联，优先级，屏蔽，中断响应的周期
- **输入输出接口（重点）**
  - **8253定时计数器**，初始化编程，给命令
  - 复习一下作业
  - **8255并行接口芯片**，三种工作方式特点
    - 简易键盘显示接口的原理
    - 如何获取键盘的键值：汇编、c
    - 设备驱动
  - 串行接口芯片
    - 异步通信字框格式
    - 8251的基本原理，方式字

## 第五章：嵌入式

- 什么是嵌入式系统
- 实时系统的概念
- 主流处理器架构
  - 补充：RISC-V
- 软硬件层次的结构



| 特性                   | tmpfs              | ramfs                    |
| ---------------------- | ------------------ | ------------------------ |
| 达到空间上限时继续写入 | 提示错误信息并终止 | 可以继续写尚未分配的空间 |
| 是否固定大小           | 是                 | 否                       |
| 是否使用swap           | 是                 | 否                       |
| 具有易失性             | 是                 | 是                       |



## 第六章：嵌入式实验

- 实验内容
  - Framebuffer的画图原理
  - 显示屏和触摸屏的坐标转换



## 第七章：linux设备驱动

- 设备驱动和应用程序的区别、内核模块的基本结构
- 三种类型的设备
- Makefile的结构，相关命令，`insmod`等
- 注册字符型设备的函数，`mknod`命令
- 文件操作结构体
- `ioctl`函数的用法



![image-20220105230531197](/assets/2022-01-01-final.assets/image-20220105230531197.png)



字符设备驱动大致框架

``` C


#include <linux/module.h> 
#include <linux/init.h>
#include <linux/fs.h>
#include <linux/uaccess.h>  /* for put_user */  //copy_to_user


/*
//自定义初始化和退出
int my_init(void);
void my_exit(void);
module_init(my_init);
module_exit(my_exit);
*/

int init_module(void)
{
    //注册
int register_chrdev(unsigned int major, const char *name, struct file_operations *fops);    
    unsigned Major = register_chrdev(0, DEVICE_NAME, &fops); //0代表由系统自动分配主设备号，
	//否则给出一个正整数就表示主设备号
}

void cleanup_module(void)
{
    int unregister_chrdev(unsigned int major, const char *name);
}    
    
int device_open(struct inode *, struct file *);
int device_release(struct inode *, struct file *);
ssize_t device_read(struct file *, char *, size_t, loff_t *);
ssize_t device_write(struct file *, const char *, size_t, loff_t *);
long device_ioctl(struct file *, unsigned int,
unsigned long);

/*
unsigned long copy_to_user(void __user *to,const void *from,unsigned long count); //将数据从内核拷贝至用户空间，用于read操作 
unsigned long copy_from_user(void *to,const void __user *from,unsigned long count); //将数据从用户空间拷贝到内核中，用于write操作
*/

struct file_operations fops = {
          read: device_read,
          write: device_write,
          open: device_open,
          release: device_release,
    	  unlocked_ioctl: device_ioctl
       };

```




## 例题

![image-20220104204828551](/assets/2022-01-01-final.assets/image-20220104204828551.png)

![image-20220104205349855](/assets/2022-01-01-final.assets/image-20220104205349855.png)



## 8255键盘

[《微机系统与接口》第八章 习题课（键盘-8255a行扫描法） - 豆丁网 (docin.com)](https://www.docin.com/p-1861582404.html)

```assembly

8255扫描键盘、显示程序
利用8255可编程并行口做一个扫描键盘实验，
把按键输入的键码，显示在由8279控制的七段数码管上。
8255PA口做键盘输入线，PB口作扫描线。

;数据指针（DPTR）是80C51（属于MCS-51系列单片机） 中一个功能比较特殊的寄存器。
;这好像是单片机的汇编程序

D8255 EQU 8506H ;8255状态/数据口地址
D8255A EQU 8500H ;8255 PA口地址
D8255B EQU 8502H ;8255 PB口地址
Z8279 EQU 8701H ;8279状态口地址
D8279 EQU 8700H ;8279数据口地址
DISPTR EQU 08H ;当前显示位置
KEYVAL EQU 09H ;读到的键码
ORG 0000H
LJMP START
ORG 0040H
MAIN:
MOV SP,#60H
LCALL DELAY ;延时
MOV DISPTR,#30H ;显示缓冲区头指针
MOV DPTR,#D8255
MOV A,#90H ;置8255状态
;方式0,PB,PC口输出,PA口输入
MOVX @DPTR,A
MOV DPTR,#Z8279 ;置8279命令字
MOV A,#0D3H
MOVX @DPTR,A ;清LED显示
MOV A,#00H
MOVX @DPTR,A
MOV A,#38H
MOVX @DPTR,A
MOV A,#0D1H
KB_DIS:
LCALL RD_KB ;读键盘
MOV A,#0FFH
CJNE A,KEYVAL,DISBUF ;判读到键
SJMP KB_DIS ;没有则继续读键
DISBUF:
LCALL DISP ;把键移入显存
LCALL DELAY ;延时消抖
LCALL DELAY
SJMP KB_DIS
DISP: ;显存依次前移
MOV R1,#31H ;在最后加入新键值
MOVE:
MOV A,@R1
DEC R1
MOV @R1,A
INC R1
INC R1
CJNE R1,#38H,MOVE
MOV 37H,KEYVAL
MOV KEYVAL,#0FFH
MOV DPTR,#Z8279
MOV A,#90H
MOVX @DPTR,A
MOV R0,#08H
MOV R1,#30H
MOV DPTR,#D8279
LP: MOV A,@R1
MOVX @DPTR,A
INC R1
DJNZ R0,LP
RET
RD_KB: ;键盘扫描
MOV A,#02H ;扫描第一行
MOV DPTR,#D8255B
MOVX @DPTR,A
MOV DPTR,#D8255A
MOVX A,@DPTR
MOV R1,#00H
CJNE A,#0FFH,KEYCAL ;判键是否按下
MOV A,#01H ;扫描第二行
MOV DPTR,#D8255B
MOVX @DPTR,A
MOV DPTR,#D8255A
MOVX A,@DPTR
MOV R1,#08H
CJNE A,#0FFH,KEYCAL
SJMP NOKEY ;无键按下
KEYCAL: ;计算键码
MOV R0,#08H
SHIFT:
RRC A
JNC CALC
INC R1
DJNZ R0,SHIFT
CALC: ;换算显示码
MOV DPTR,#DL_DAT
MOV A,R1
MOVC A,@A+DPTR
MOV KEYVAL,A
RET
NOKEY: MOV KEYVAL,#0FFH ;返回无键标志
RET
DELAY: MOV R0,#0H ;延时子程序
DELAY1: MOV R1,#0H
DJNZ R1,$
DJNZ R0,DELAY1
RET
DL_DAT: DB 3FH,06H,5BH,4FH,66H,6DH,7DH,07H ;0,1,2,3,4,5,6,7
DB 7FH,6FH,77H,7CH,39H,5EH,79H,71H ;8,9,A,B,C,D,E,F
END
```



```assembly
PORT_A EQU 0FF9H;8255A端口地址
PORT_B EQU 0FFBH;8255B端口地址
PORT_CTL EQU 0FFFH;8255C端口地址
;数据段定义,键盘扫描表
DATA	SEGMENT	
; 
TABLE DB 77H,7B,7D,7E,0B7H,0BBH,0BDH,0BEH
	  DB 0D7H,0DBH,0DDH,0DEH,0E7H,0EBH,0EEH
DATA ENDS
;堆栈段
STACK SEGMENT	STACK
		DW 50 DUP(0)
TOP_STACK LABEL	WORD	
STACK ENDS
;代码段
CODE SEGMENT	
	ASSUME	CS:CODE,DS:DATA,SS:STACK
MAIN: MOV AX,STACK
	MOV DX,AX;
	LEA	SP	TOP_STACK
	MOV AX,DATA
	MOV DX,AX
;初始化8255A输出BC输入
MOV DX, PROT_CTL
MOV AL,10001011B
OUT DX,AL	
;向每一行清0
MOV	AL,0
MOV DX,PORR_A
OUT DX,AL
MOV DX,PORT_B
;读列看是否有键被按下
WAIT_OPEN:
IN AL,DX
AND AL,0FH
CMP	AL,0FH
JNE WAIT_OPEN
WAIT_PRES:
IN AL,DX
AND AL,0FH
CMP	AL,0FH
JE WAIT_PRES	
MOV CX 16EAH
DELAY: LOOP DELAY
IN AL,DX
AND AL,0FH
CMP AL,0FH
JNZ WAIT_PRES
;键还是被压着,确定哪一个
MOV AL,0FEH
MOV CL,AL
NEXT_ROW:MOV DX,PORT_A
		OUT DX,AL
		MOV DX,PORT_B
		IN AL,DX
		AND AL,0FH
		CMP AL,0FH
		JNE ENCODE
		ROL	CL,01
		MOV AL,CL
		JMP NEXT_ROW	
;找到了一对低电平
ENCODE:
	MOV BX,000FH
	IN AL,DX
NEXT_TRY:CMP AL,TABLE[BX]
		JE DONE
		DEC BX
		JNS NEXT_TRY
		MOV AH,01H
		JMP EXIT

DONE:
	MOV AL,BL
	MOV AH,00

EXIT: HLT	
CODE	ENDS
	END

```

