{"/weekly%20reports/2022-01-07-test1.html": {
    "title": "周报1",
    "keywords": "Weekly Reports",
    "url": "/weekly%20reports/2022-01-07-test1.html",
    "body": "没啥"
  },"/python/2022-01-07-Python.html": {
    "title": "Python专栏",
    "keywords": "Python",
    "url": "/python/2022-01-07-Python.html",
    "body": "一级标题根据yaml front matter取为Python专栏 复习 期末复习 这是一个三级标题 这是一个四级标题"
  },"/python/2022-01-01-final.html": {
    "title": "期末复习",
    "keywords": "Python",
    "url": "/python/2022-01-01-final.html",
    "body": "微机原理复习题目(带答案) - 道客巴巴 (doc88.com) 微机原理试题及答案 (ruiwen.com) 微机原理试题集题库(带答案) - 豆丁网 (docin.com) 微机原理复习题目 (带答案） - 道客巴巴 (doc88.com) 微机接口技术与应用_习题集(含答案) - 道客巴巴 (doc88.com) 大纲 第一章：微处理器基础 数值信息的表示：浮点数转换，原码补码，常见字符的ASCII码，汉字编码的原理 字符 ASCII码（American Standard Code for Information Interchange） ‘0’ 48 ‘A’ 65 ‘a’ 97 补码表示的16位带符号数字8088H除以8 1000 0000 1000 1000 原码 1111 1111 0111 1000 除以8 -111 1111 0111 1000/1000=-111 1111 0111 1= -1111 1110 1111=1000 1111 1110 1111 -&gt; 1111 0000 0001 0001 这个情况比较特殊，刚好能整除，最后的结果相当于原数右移3位，最高位补符号位1 定点除法比较复杂，可以用不恢复余数法（也叫加减交替法；原码/补码除法） 补码除法规则说明 - 百度文库 (baidu.com) 同符号的数相减会有进位、不会有溢出？ 第二章：微型计算机原理与体系结构 冯诺依曼组成原理，改进的哈佛结构，本质区别 8086的内核结构，寄存器基本作用，地址线条数，寻址 80386的变化，结构特点，分段分页的作用，保护地址，GDTR，LDTR，地址计算 CISC和RISC的区别 存储字系统金字塔，是什么，为什么 流水线是什么，什么是超标量 寻址方式 第三章：总线与存储 总线的特性、分类、三态逻辑 异步通信的原理，双方握手 总线的性能指标 存储器的分类、存储器的层次 静态和动态RAM的比较 大小端模式 存储器的地址计算 存储器的容量扩展 存储器和CPU的连接，SRAM和DRAM的区别 存储器习题解答 - 百度文库 (baidu.com) 数据总线(data bus) — 传输数据、状态信息(双向、三态) 地址总线(address bus) — 传输地址信息(单向、三态) 控制总线(control bus) — 传输控制信号(单向) 8086存储器分为偶体寄存器与奇体存储器 该存储器的存储容量为2^16*16bit；A16-19地址引脚是固定的，由高到低分别为1100，地址范围为C0000H到CFFFFH 右边那列由A0选通，存取的是偶数位地址；左边那列由~BHE选中高地址 1.8086cpu访问偶地址的字节单元时，cpu输出A0=0,选中偶体存储器，数据总线的低8位上传输，花费一个总线周期。 2.访问奇地址的字节单元时，输出A0=1, ~BHE低电平，选中奇体存储器，数据在数据总线的高8位上传输，花费一个总线周期。 3.访问偶地址开始的一个字单元时，此时输出A0=0, ~BHE=0，两个存储器同时被选中，数据线的低8位与高8位同时传输，因此，对所有位于偶地址的字单元，8086只需要一个总线周期。 4.访问奇地址开始的一个字单元时，第一个总线周期，cpu输出A0=1，~BHE=0,奇体存储器被选中，奇体存储器中低字节数据在数据总线的高8位上传输，第二个总线周期，cpu=A0, ~BHE=1，偶体存储器被选中，数据在数据总线的低8位上传输。 Cache 直接映射 主存地址格式：主存区号-区内块号-块内地址 Cache地址格式：区内块号-块内地址 全相连映射 主存：主存块号-块内地址 Cache：Cache块号-块内地址 n路（即每组包含n块）组相联映射 主存：主存区号-区内块号-块内地址 Cache：Cache组号-块号-块内地址 DRAM 行列复用，相当于有9*2=18根地址线，所以最大容量为$2^{18}*8bit$=256KB 地址/数据总线复用的情况下，存储器地址线和CPU地址线引脚需通过地址锁存器相连 选C，为什么？ 选A，内部中断优先级最高？ 第四章：数据传输与输入输出接口 数据传输方式：查询，中断，DMA，三种方式的特点，区别 中断控制器芯片8259的基本特点，多片级联，优先级，屏蔽，中断响应的周期 输入输出接口（重点） 8253定时计数器，初始化编程，给命令 复习一下作业 8255并行接口芯片，三种工作方式特点 简易键盘显示接口的原理 如何获取键盘的键值：汇编、c 设备驱动 串行接口芯片 异步通信字框格式 8251的基本原理，方式字 第五章：嵌入式 什么是嵌入式系统 实时系统的概念 主流处理器架构 补充：RISC-V 软硬件层次的结构 特性 tmpfs ramfs 达到空间上限时继续写入 提示错误信息并终止 可以继续写尚未分配的空间 是否固定大小 是 否 是否使用swap 是 否 具有易失性 是 是 第六章：嵌入式实验 实验内容 Framebuffer的画图原理 显示屏和触摸屏的坐标转换 第七章：linux设备驱动 设备驱动和应用程序的区别、内核模块的基本结构 三种类型的设备 Makefile的结构，相关命令，insmod等 注册字符型设备的函数，mknod命令 文件操作结构体 ioctl函数的用法 字符设备驱动大致框架 #include &lt;linux/module.h&gt; #include &lt;linux/init.h&gt; #include &lt;linux/fs.h&gt; #include &lt;linux/uaccess.h&gt; /* for put_user */ //copy_to_user /* //自定义初始化和退出 int my_init(void); void my_exit(void); module_init(my_init); module_exit(my_exit); */ int init_module(void) { //注册 int register_chrdev(unsigned int major, const char *name, struct file_operations *fops); unsigned Major = register_chrdev(0, DEVICE_NAME, &amp;fops); //0代表由系统自动分配主设备号， //否则给出一个正整数就表示主设备号 } void cleanup_module(void) { int unregister_chrdev(unsigned int major, const char *name); } int device_open(struct inode *, struct file *); int device_release(struct inode *, struct file *); ssize_t device_read(struct file *, char *, size_t, loff_t *); ssize_t device_write(struct file *, const char *, size_t, loff_t *); long device_ioctl(struct file *, unsigned int, unsigned long); /* unsigned long copy_to_user(void __user *to,const void *from,unsigned long count); //将数据从内核拷贝至用户空间，用于read操作 unsigned long copy_from_user(void *to,const void __user *from,unsigned long count); //将数据从用户空间拷贝到内核中，用于write操作 */ struct file_operations fops = { read: device_read, write: device_write, open: device_open, release: device_release, unlocked_ioctl: device_ioctl }; 例题 8255键盘 《微机系统与接口》第八章 习题课（键盘-8255a行扫描法） - 豆丁网 (docin.com) 8255扫描键盘、显示程序 利用8255可编程并行口做一个扫描键盘实验， 把按键输入的键码，显示在由8279控制的七段数码管上。 8255PA口做键盘输入线，PB口作扫描线。 ;数据指针（DPTR）是80C51（属于MCS-51系列单片机） 中一个功能比较特殊的寄存器。 ;这好像是单片机的汇编程序 D8255 EQU 8506H ;8255状态/数据口地址 D8255A EQU 8500H ;8255 PA口地址 D8255B EQU 8502H ;8255 PB口地址 Z8279 EQU 8701H ;8279状态口地址 D8279 EQU 8700H ;8279数据口地址 DISPTR EQU 08H ;当前显示位置 KEYVAL EQU 09H ;读到的键码 ORG 0000H LJMP START ORG 0040H MAIN: MOV SP,#60H LCALL DELAY ;延时 MOV DISPTR,#30H ;显示缓冲区头指针 MOV DPTR,#D8255 MOV A,#90H ;置8255状态 ;方式0,PB,PC口输出,PA口输入 MOVX @DPTR,A MOV DPTR,#Z8279 ;置8279命令字 MOV A,#0D3H MOVX @DPTR,A ;清LED显示 MOV A,#00H MOVX @DPTR,A MOV A,#38H MOVX @DPTR,A MOV A,#0D1H KB_DIS: LCALL RD_KB ;读键盘 MOV A,#0FFH CJNE A,KEYVAL,DISBUF ;判读到键 SJMP KB_DIS ;没有则继续读键 DISBUF: LCALL DISP ;把键移入显存 LCALL DELAY ;延时消抖 LCALL DELAY SJMP KB_DIS DISP: ;显存依次前移 MOV R1,#31H ;在最后加入新键值 MOVE: MOV A,@R1 DEC R1 MOV @R1,A INC R1 INC R1 CJNE R1,#38H,MOVE MOV 37H,KEYVAL MOV KEYVAL,#0FFH MOV DPTR,#Z8279 MOV A,#90H MOVX @DPTR,A MOV R0,#08H MOV R1,#30H MOV DPTR,#D8279 LP: MOV A,@R1 MOVX @DPTR,A INC R1 DJNZ R0,LP RET RD_KB: ;键盘扫描 MOV A,#02H ;扫描第一行 MOV DPTR,#D8255B MOVX @DPTR,A MOV DPTR,#D8255A MOVX A,@DPTR MOV R1,#00H CJNE A,#0FFH,KEYCAL ;判键是否按下 MOV A,#01H ;扫描第二行 MOV DPTR,#D8255B MOVX @DPTR,A MOV DPTR,#D8255A MOVX A,@DPTR MOV R1,#08H CJNE A,#0FFH,KEYCAL SJMP NOKEY ;无键按下 KEYCAL: ;计算键码 MOV R0,#08H SHIFT: RRC A JNC CALC INC R1 DJNZ R0,SHIFT CALC: ;换算显示码 MOV DPTR,#DL_DAT MOV A,R1 MOVC A,@A+DPTR MOV KEYVAL,A RET NOKEY: MOV KEYVAL,#0FFH ;返回无键标志 RET DELAY: MOV R0,#0H ;延时子程序 DELAY1: MOV R1,#0H DJNZ R1,$ DJNZ R0,DELAY1 RET DL_DAT: DB 3FH,06H,5BH,4FH,66H,6DH,7DH,07H ;0,1,2,3,4,5,6,7 DB 7FH,6FH,77H,7CH,39H,5EH,79H,71H ;8,9,A,B,C,D,E,F END PORT_A EQU 0FF9H;8255A端口地址 PORT_B EQU 0FFBH;8255B端口地址 PORT_CTL EQU 0FFFH;8255C端口地址 ;数据段定义,键盘扫描表 DATA SEGMENT ; TABLE DB 77H,7B,7D,7E,0B7H,0BBH,0BDH,0BEH DB 0D7H,0DBH,0DDH,0DEH,0E7H,0EBH,0EEH DATA ENDS ;堆栈段 STACK SEGMENT STACK DW 50 DUP(0) TOP_STACK LABEL WORD STACK ENDS ;代码段 CODE SEGMENT ASSUME CS:CODE,DS:DATA,SS:STACK MAIN: MOV AX,STACK MOV DX,AX; LEA SP TOP_STACK MOV AX,DATA MOV DX,AX ;初始化8255A输出BC输入 MOV DX, PROT_CTL MOV AL,10001011B OUT DX,AL ;向每一行清0 MOV AL,0 MOV DX,PORR_A OUT DX,AL MOV DX,PORT_B ;读列看是否有键被按下 WAIT_OPEN: IN AL,DX AND AL,0FH CMP AL,0FH JNE WAIT_OPEN WAIT_PRES: IN AL,DX AND AL,0FH CMP AL,0FH JE WAIT_PRES MOV CX 16EAH DELAY: LOOP DELAY IN AL,DX AND AL,0FH CMP AL,0FH JNZ WAIT_PRES ;键还是被压着,确定哪一个 MOV AL,0FEH MOV CL,AL NEXT_ROW:MOV DX,PORT_A OUT DX,AL MOV DX,PORT_B IN AL,DX AND AL,0FH CMP AL,0FH JNE ENCODE ROL CL,01 MOV AL,CL JMP NEXT_ROW ;找到了一对低电平 ENCODE: MOV BX,000FH IN AL,DX NEXT_TRY:CMP AL,TABLE[BX] JE DONE DEC BX JNS NEXT_TRY MOV AH,01H JMP EXIT DONE: MOV AL,BL MOV AH,00 EXIT: HLT CODE ENDS END"
  },"/jekyll/2019-04-28-toc.html": {
    "title": "How to Generate TOC",
    "keywords": "Jekyll",
    "url": "/jekyll/2019-04-28-toc.html",
    "body": "The jekyll-gitbook theme leverages jekyll-toc to generate the Contents for the page. The TOC feature is not enabled by default. To use the TOC feature, modify the TOC configuration in _config.yml: toc: enabled: true Why this repo long contents ….. a b c d Why this repo long contents ….. 1 2 3 4 Why this repo long contents ….. e f g h Why this repo 5 6 7 8 Why this repo long contents ….. a b c d Why this repo long contents ….. 1 2 3 4 Why this repo long contents ….. e f g h Why this repo 5 6 7 8 Why this repo long contents ….. a b c d Why this repo long contents ….. 1 2 3 4 Why this repo long contents ….. e f g h Why this repo 5 6 7 8 Why this repo long contents ….. a b c d Why this repo long contents ….. 1 2 3 4 Why this repo long contents ….. e f g h Why this repo 5 6 7 8"
  },"/jekyll/2019-04-27-why.html": {
    "title": "Why Jekyll with GitBook",
    "keywords": "Jekyll",
    "url": "/jekyll/2019-04-27-why.html",
    "body": "GitBook is an amazing frontend style to present and organize contents (such as book chapters and blogs) on Web. The typical to deploy GitBook at Github Pages is building HTML files locally and then push to Github repository, usually to the gh-pages branch. However, it’s quite annoying to repeat such workload and make it hard for people do version control via git for when there are generated HTML files to be staged in and out. This theme takes style definition out of generated GitBook site and provided the template for Jekyll to rendering markdown documents to HTML, thus the whole site can be deployed to Github Pages without generating and uploading HTML bundle every time when there are changes to the original repository."
  }}
